---
id: 0.2
title: 0.2 服务端和客户端
description: 服务端和客户端
hide_table_of_contents: false
sidebar_position: 102
---

# 服务端和客户端

有关服务端和客户端的内容十分重要，值得我们在绪论之后单独开一节来讲。

---

如果你曾经自己开过服务器来玩，你应该就知道服务端和客户端是不同的。多人游戏时，物理服务端和物理客户端运行在不同的物理主机上，通过网络传输信息。而即使在单人游戏中，MC也存在一个逻辑服务端和一个逻辑客户端。

显然，有些数据需要在正确的一端进行运算，并同步至另外一端（幽灵方块就是个典型的反面例子）；有些数据只在一端存在（比如粒子效果）。单人游戏时两端在不同线程上运行，多人游戏时两端在不同设备上运行，显然这需要数据同步、更新才能保证程序的准确运行。

## 你是哪端的？

有一些方法在两端都会被执行，而一些时候我们希望在不同侧执行不同的逻辑，这就需要分辨。而通常参数中都会有`Level`：

```java
public void bothSideMethod(Level level){
    if (level.isClientSide){
        //客户端逻辑
    } else {
        //服务端逻辑
    }
}
```

借助`level.isClientSide`，我们可以判断传入的参数是对应逻辑服务端还是逻辑客户端。

## 获取服务端和客户端

在多数时候，方法的形参带有`level`，我们可以直接使用上面的方法来实现想要的逻辑。但偶尔我们需要“凭空”获取两端。

在客户端，要想获取客户端十分简单：

```java
Minecraft minecraft = Minecraft.getInstance();
//如果你还想要Level
ClientLevel clientLevel = minecraft.level;
```

在服务端，你需要借助`LogicalSidedProvider`：

```java
MinecraftServer minecraftServer = (MinecraftServer) LogicalSidedProvider.WORKQUEUE.get(LogicalSide.SERVER);
//如果你还想要Level，由于有多个Level存在，你需要提前通过其他方法获取ResourceKey<Level>
//原版三个世界的ResourceKey在Level类中可以找到，以主世界为例：
ServerLevel serverLevel = minecraftServer.getLevel(Level.OVERWORLD);
//当然，你可以遍历所有的level，通过某种条件来找到自己想要的。但请尽量不要这样做，除非真的很有必要，没有其他方法，或者你已经尽了最大可能减少性能开销。
```

当然你也可以使用`LogicalSidedProvider`来获取客户端，但是在多数时候显然不如直接使用`Minecraft.getInstance()`来的方便。

你也可以使用`DistExecutor`来分辨两端并执行逻辑，但上述的方法在绝大多数时候已经足够了。



## OnlyIn！

<div style={{
    backgroundColor: 'transparent',
    border: '2px solid #3c91ff',
    borderRadius: '0.5em',
    padding: '1em',
  }}>
<Tabs groupId="mc-version">
<TabItem value="1217" label="1.21.7">
:::caution

在1.21.7，OnlyIn遭到了彻底的降级。现在OnlyIn不再起任何实际作用，NeoForge会检查你是否还在用，并且在游戏启动时给出警告——如果你正在升级版本，应该很快就能发现这个问题。这也意味着，你需要自行处理这个双端分离的问题。参考[OnlyIn，但是为什么？](#onlyin但是为什么)了解更多内容。

:::

</TabItem>
</Tabs>

<p></p>
</div>

<p></p>

如果你因为好奇而查看了`ClientLevel`的具体内容，你可能已经注意到了这样一个注解`@OnlyIn(Dist.CLIENT)`。括号中的value一般是`Dist.CLIENT`，极少数时候会用到`Dist.DEDICATED_SERVER`。字段、方法等一旦被`@OnlyIn`注解，他们对于另一端就是逻辑上不可见的（即使这几行代码确实存在于磁盘之中）。请注意，`@OnlyIn`区分的是物理两端而不是逻辑两端。这意味着单人游戏中的服务端可以执行被注解`@OnlyIn(Dist.CLIENT)`的代码，而`@OnlyIn(Dist.DEDICATED_SERVER)`在单人游戏时意味着谁也不能执行到它。

对于被`@OnlyIn`标记的类，需要注意的是，即使你已经用了`isClientSide`来区分，你也不能在一个双端方法内使用它（的对象），需要单独拆出来：

```java
//这是一个错误的用法
public void bothSideMethodWrong(Level level){
    if (level.isClientSide){
        Minecraft minecraft = Minecraft.getInstance();
        //客户端逻辑
    } else {
        MinecraftServer minecraftServer = (MinecraftServer) LogicalSidedProvider.WORKQUEUE.get(LogicalSide.SERVER);
        //服务端逻辑
    }
}

//这是一个正确的用法
public void bothSideMethodCorrect(Level level){
    if (level.isClientSide){
        doClientStuff();
    } else {
        doServerStuff();
    }
}

private void doClientStuff(){
    Minecraft minecraft = Minecraft.getInstance();
    //客户端逻辑
}

private void doServerStuff(){
    MinecraftServer minecraftServer = (MinecraftServer) LogicalSidedProvider.WORKQUEUE.get(LogicalSide.SERVER);
    //服务端逻辑
}
```
在你第一次启动`runServer`时，你很有可能遇到这样的报错：

> Caused by: java.lang.BootstrapMethodError: java.lang.RuntimeException: Attempted to load class net/minecraft/client/resources/sounds/SoundInstance for invalid dist DEDICATED_SERVER

你可能会感到很疑惑：我明明已经在我的实体/物品/方块类中像上面说的一样，把两端方法分开写了啊？

请检查你的类**成员变量**中是否像这样，有单端对象：

```java
//来自之前版本的Extinguish, 由于过时而采用BSD-3
public abstract class AbstractFireExtinguisher extends Item {
    private final int maxTime;
    private static final Predicate<Entity> ALL_BUT_SPECTATOR = entity -> !entity.isSpectator();
    private static final double INTERACT_DISTANCE = 7;
    FollowingSoundInstance soundInstanceBuffer = null;
...
```

> 其中的`FollowingSoundInstance`继承自`SimpleSoundInstance`，而`SimpleSoundInstance`显然有着`@OnlyIn`的注解。

如此的话，你需要在你的单端方法上也加上`@OnlyIn`的注解（成员变量的定义处也加上），这样Forge/FML就会替你把这个方法也变成仅客户端可见的：

```java
...
    @OnlyIn(Dist.CLIENT)
    FollowingSoundInstance soundInstanceBuffer = null;
...
//来自之前版本的Extinguish, 由于过时而采用BSD-3
    @OnlyIn(Dist.CLIENT)
    public void stopClientSound() {
        if (soundInstanceBuffer != null) {
            Minecraft.getInstance().getSoundManager().stop(soundInstanceBuffer);
            soundInstanceBuffer = null;
        }
    }
```

### 一些争议

一些开发者声称，“没有任何理由在mod中使用`@OnlyIn`。”他们会建议你将类或方法分离出去，写到一个单独的包或者类中，从而完全规避使用它。

我的观点是：

- 你应该仅出于规避`ClassNotFoundException`或者`BootstrapMethodError`之类，由原版使用了`@OnlyIn`，但你没有专门处理而产生的错误。是的，这种情况也可以通过上述的分离来解决，但大多数适合是不划算的——我可能只是需要一行`Minecraft.getInstance()...;`，而不是什么复杂的逻辑。而当你的逻辑达到一定长度时，你就更可能需要将他们拆分出去——但总之这是你的自由。
- 但另一种情况是，你编写了某个类或者方法，想（在以后）提醒你自己或其他开发者只能在客户端使用他们。这样的话，你更应该在你的包、类或方法名称里加上`Client`字样来区分——而不是使用`@OnlyIn`。

综上，我只推荐你被动地使用`@OnlyIn`，而不应该主动地使用它——鬼知道以后会在哪里给你搞出`ClassNotFoundException`。



## 数据同步

显然我们需要时不时地把服务端的变动同步到客户端，把客户端的输入同步到服务端，不然两边都不知道对面在干嘛。

好消息是，MC已经给我们造好了一大堆轮子可以直接使用。坏消息是，有些时候这些原版提供的轮子并不够用，需要我们手动发包同步。不同类有不同的方法来进行同步，而最通用的方式是手动发包，我将会在[5 网络包](/holojaneway/5)一节讲解。其他方式的详细内容会在涉及到的时候再讲。

---

## 奇奇怪怪的注意事项

### OnlyIn，但是为什么？

从1.21.7开始，由于你不能再使用@OnlyIn，就需要额外注意客户端与服务端代码分离。考虑这样一个示例：

```java
public class Example {
    public void foo(){
        Minecraft.getInstance()...;
    }
    
    public void bar(){
        System.out.println("bar");
    }
}
```

显然你不能在服务端调用`example.foo()`，这会立即导致`ClassNotFoundException/NoClassDefFoundError`。

但是如果在服务端调用`example.bar()`呢？我们都知道实际的类加载只会在程序跑到那里时才会触发，是否意味着只要我们私下约定不在服务端调用`foo()`，就不会出问题？

并非如此。显然，在你获取`example`对象之前，JVM需要先加载`Example`这个类。在加载过程中，JVM还需要进行验证、解析、链接等操作，而在这些操作中，根据不同的实现，JVM可以把类的方法中局部用到的类也一并加载。

然后，boom——但是这样听起来很不合理，对吧？我明明可以信心十足地约定或保证`foo()`不会在服务端被用到，何苦一定要拆成`ExampleC`和`ExampleS`两个类呢？

当然也有办法，我们注意到刚才只是说“JVM可以把类的方法中局部用到的类也一并加载”，那我们可以把`foo()`的内容用一个`Runnable`套起来，就像这样：

```java
    public void foo(){
        Runnable run = new Runnable(){
            public void run(){
                Minecraft.getInstance()...;
            }
        }
        run.run();
    }
```

当`Example`加载的时候，就只会加载到`Runnable`这个类——而这个类本身里面什么也没有。等到真正开始执行`foo()`，才会尝试加载`Minecraft`类。

:::info

编译器或许还会提示你，`new Runnable()`可以写成lambda形式——在这里是万万不能的。`new Runnable(){}`是创建了一个新的匿名内部类，而lambda表达式则会直接调用`lambdaMetaFactory`来进行处理，在此过程中仍然会导致加载方法体内的内容。这是一个值得注意的微妙差别。

:::

当然这样并不方便，你或许可以像T88一样搞个编译器插件，甚至是直接用Manifold插件写个宏——但尽量还是直接分成两个类吧。
