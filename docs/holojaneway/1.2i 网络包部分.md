---
id: 1.2i
title: 1.2i 网络包
description: T88使用文档-网络包
hide_table_of_contents: false


---

# 网络包注解处理器

基础的使用介绍参考[网络包](5)一节。



## ClientHandler

在1.21.7之前，你可能习惯于直接在网络包的`clientHandler`方法里调用仅客户端的类，然后在方法上加`OnlyIn`。显然这个方法在新版本已经不适用，为了方便你的编写，T88提供一个简单的编译器插件，能够在编译时自动把`clientHandler`方法体用`Runnable`包起来以实现延迟加载。

为了使用这个插件，除去常规的导入之外：

```groovy
dependencies {
    implementation "net.neoforged:neoforge:${neo_version}"
    
    implementation("cn.ussshenzhou:t88:0.+")
    annotationProcessor("cn.ussshenzhou:t88:0.+")
}
```

还需要在你的`build.gradle`里加上这么一段：

```groovy
tasks.withType(JavaCompile).configureEach {
    options.fork = true
    options.forkOptions.jvmArgs += [
            '--add-exports', 'jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED',
            '--add-exports', 'jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED',
            '--add-exports', 'jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED',
            '--add-exports', 'jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED',
    ]
    options.compilerArgs += ['-Xplugin:T88ClientHandlerWrapper']
}
```

然后重新编译项目，对比源代码的从字节码反编译的结果：

```java
    @ClientHandler
    public void clientHandler(IPayloadContext context) {
        Level level = Minecraft.getInstance().level;
        if (level != null) {
            Random r = new Random();
            var player = Minecraft.getInstance().level.getPlayerByUUID(sourcePlayerUUID);
            if (player == null) {
                return;
            }
            var posOffset = getNozzlePosInWorld(player, 4, 0);
            var speed = getSpeedVec(player);
            for (int i = 0; i < particleOption.amount(); i++) {
                level.addParticle(
                        particleOption,
                        true,
                        particleOption.alwaysRender().get(),
                        posOffset.x + MathHelper.signedRandom(r) * particleOption.xDiffuse(),
                        posOffset.y + MathHelper.signedRandom(r) * particleOption.yDiffuse(),
                        posOffset.z + MathHelper.signedRandom(r) * particleOption.zDiffuse(),
                        speed.x + MathHelper.signedRandom(r) * particleOption.vxDiffuse(),
                        speed.y + MathHelper.signedRandom(r) * particleOption.vyDiffuse(),
                        speed.z + MathHelper.signedRandom(r) * particleOption.vzDiffuse()
                );
            }
        }
    }
```

```java
    public void clientHandler(IPayloadContext context) {
        Runnable wrapped = new Runnable() {
            public void run() {
                Level level = Minecraft.getInstance().level;
                if (level != null) {
                    Random r = new Random();
                    Player player = Minecraft.getInstance().level.getPlayerByUUID(MadParticleTadaPacket.this.sourcePlayerUUID);
                    if (player == null) {
                        return;
                    }

                    Vec3 posOffset = MadParticleTadaPacket.this.getNozzlePosInWorld(player, 4.0F, 0.0F);
                    Vec3 speed = MadParticleTadaPacket.this.getSpeedVec(player);

                    for(int i = 0; i < MadParticleTadaPacket.this.particleOption.amount(); ++i) {
                        level.addParticle(MadParticleTadaPacket.this.particleOption, true, MadParticleTadaPacket.this.particleOption.alwaysRender().get(), posOffset.x + MathHelper.signedRandom(r) * (double)MadParticleTadaPacket.this.particleOption.xDiffuse(), posOffset.y + MathHelper.signedRandom(r) * (double)MadParticleTadaPacket.this.particleOption.yDiffuse(), posOffset.z + MathHelper.signedRandom(r) * (double)MadParticleTadaPacket.this.particleOption.zDiffuse(), speed.x + MathHelper.signedRandom(r) * (double)MadParticleTadaPacket.this.particleOption.vxDiffuse(), speed.y + MathHelper.signedRandom(r) * (double)MadParticleTadaPacket.this.particleOption.vyDiffuse(), speed.z + MathHelper.signedRandom(r) * (double)MadParticleTadaPacket.this.particleOption.vzDiffuse());
                    }
                }

            }
        };
        wrapped.run();
    }
```

:::tip

在此过程中，`T88ClientHandlerWrapper`会自动地将`this`和`super`转换成`OuterClass.this`和`OuterClass.super`，但需要注意的是，T88并不会主动处理匿名内部类方法要求参数均为effective final的特性，effective final依靠方法体内实现自行保证。

:::
